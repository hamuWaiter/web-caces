<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<canvas id="canvas" width="600" height="300" style="border:1px solid black"></canvas>
	</body>
	<script>
		// 当小球接触到边界时，让晓求得速度方向方向，即可实现碰撞反弹

		var canvas = document.getElementById('canvas');
		var ctx = canvas.getContext('2d');
		var raf;

		var ball = {
			x: 100,
			y: 100,
			vx: 5,
			vy: 2,
			radius: 25,
			color: 'blue',
			draw: function() {
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
				ctx.closePath();
				ctx.fillStyle = this.color;
				ctx.fill();
			}
		};

		function draw() {

			// 3. 拖尾效果：
			// 现在，使用的是 clearRect 函数帮我们清除前一帧动画。若用一个半透明的
			// fillRect 函数取代之，就可轻松制作长尾效果。

			// ctx.clearRect(0,0, canvas.width, canvas.height);

			ctx.fillStyle = 'rgba(255,255,255,0.3)';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			ball.draw();
			// 1. 边界反弹处理
			if (ball.y + ball.vy > canvas.height || ball.y + ball.vy < 0) {
				ball.vy = -ball.vy;
			}else{
				// 2. 加速度:
				// 为了让动作更真实，你可以像这样处理速度，例如：
				// 这样处理会出现类似于接触到边界弹跳起来，然后再次接触再次弹跳
				// 最后停下来的效果
				ball.vy *= .99;
				ball.vy += .25;
			}
			if (ball.x + ball.vx > canvas.width || ball.x + ball.vx < 0) {
				ball.vx = -ball.vx;
			}

			ball.x += ball.vx;
			ball.y += ball.vy;
			raf = window.requestAnimationFrame(draw);
		}

		canvas.addEventListener('mouseover', function(e) {
			raf = window.requestAnimationFrame(draw);
		});

		canvas.addEventListener('mouseout', function(e) {
			window.cancelAnimationFrame(raf);
		});

		ball.draw();
	</script>
</html>
